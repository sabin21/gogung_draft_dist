import{BackSide,BoxBufferGeometry,CubeCamera,Mesh,NoBlending,PerspectiveCamera,Scene,ShaderMaterial,UniformsUtils,WebGLRenderTargetCube}from"../../../build/three.module.js";var CubemapGenerator=function(t){this.renderer=t};CubemapGenerator.prototype.fromEquirectangular=function(t,e){e=e||{};var r=new Scene,n={tEquirect:{value:null}},i="\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t//include <common>\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t\t",a="\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t//include <common>\n\t\t\t#define RECIPROCAL_PI 0.31830988618\n\t\t\t#define RECIPROCAL_PI2 0.15915494\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV;\n\n\t\t\t\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\t\t\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t\t",o=new ShaderMaterial({type:"CubemapFromEquirect",uniforms:UniformsUtils.clone(n),vertexShader:i,fragmentShader:a,side:BackSide,blending:NoBlending});o.uniforms.tEquirect.value=t;var u=new Mesh(new BoxBufferGeometry(5,5,5),o);r.add(u);var s=e.resolution||512,l={type:t.type,format:t.format,encoding:t.encoding,generateMipmaps:void 0!==e.generateMipmaps?e.generateMipmaps:t.generateMipmaps,minFilter:void 0!==e.minFilter?e.minFilter:t.minFilter,magFilter:void 0!==e.magFilter?e.magFilter:t.magFilter},c=new CubeCamera(1,10,s,l);return c.update(this.renderer,r),u.geometry.dispose(),u.material.dispose(),c.renderTarget};var EquirectangularToCubeGenerator=function(){var t,e=new PerspectiveCamera(90,1,.1,10),r=new Scene,n=new Mesh(new BoxBufferGeometry(1,1,1),((t=new ShaderMaterial({uniforms:{equirectangularMap:{value:null}},vertexShader:"varying vec3 localPosition;\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tlocalPosition = position;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec3 localPosition;\n\t\t\t\tuniform sampler2D equirectangularMap;\n\t\t\t\t\n\t\t\t\tvec2 EquirectangularSampleUV(vec3 v) {\n\t\t\t\t\tvec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n\t\t\t\t\tuv *= vec2(0.1591, 0.3183); // inverse atan\n\t\t\t\t\tuv += 0.5;\n\t\t\t\t\treturn uv;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 uv = EquirectangularSampleUV(normalize(localPosition));\n\t\t\t\t\tgl_FragColor = texture2D(equirectangularMap, uv);\n\t\t\t\t}",blending:NoBlending})).type="EquirectangularToCubeGenerator",t));n.material.side=BackSide,r.add(n);var i=function(t,e){e=e||{},this.sourceTexture=t,this.resolution=e.resolution||512,this.views=[{t:[1,0,0],u:[0,-1,0]},{t:[-1,0,0],u:[0,-1,0]},{t:[0,1,0],u:[0,0,1]},{t:[0,-1,0],u:[0,0,-1]},{t:[0,0,1],u:[0,-1,0]},{t:[0,0,-1],u:[0,-1,0]}];var r={format:e.format||this.sourceTexture.format,magFilter:this.sourceTexture.magFilter,minFilter:this.sourceTexture.minFilter,type:e.type||this.sourceTexture.type,generateMipmaps:this.sourceTexture.generateMipmaps,anisotropy:this.sourceTexture.anisotropy,encoding:this.sourceTexture.encoding};this.renderTarget=new WebGLRenderTargetCube(this.resolution,this.resolution,r)};return i.prototype={constructor:i,update:function(t){var i=t.getRenderTarget();n.material.uniforms.equirectangularMap.value=this.sourceTexture;for(var a=0;a<6;a++){var o=this.views[a];e.position.set(0,0,0),e.up.set(o.u[0],o.u[1],o.u[2]),e.lookAt(o.t[0],o.t[1],o.t[2]),t.setRenderTarget(this.renderTarget,a),t.clear(),t.render(r,e)}return t.setRenderTarget(i),this.renderTarget.texture},dispose:function(){this.renderTarget.dispose()}},i}();export{CubemapGenerator,EquirectangularToCubeGenerator};