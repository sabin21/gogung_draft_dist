import{BufferAttribute,BufferGeometry,LineSegments,Mesh,Points}from"../../../../../build/three.module.js";const MeshReceiver=function(e){this.logging={enabled:!1,debug:!1},this.callbacks={onProgress:null,onMeshAlter:null},this.materialHandler=e};MeshReceiver.prototype={constructor:MeshReceiver,setLogging:function(e,t){this.logging.enabled=!0===e,this.logging.debug=!0===t},_setCallbacks:function(e,t){null!=e&&e instanceof Function&&(this.callbacks.onProgress=e),null!=t&&t instanceof Function&&(this.callbacks.onMeshAlter=t)},buildMeshes:function(e){let t,r,s,i=e.params.meshName,n=e.buffers,l=new BufferGeometry;void 0!==n.vertices&&null!==n.vertices&&l.addAttribute("position",new BufferAttribute(new Float32Array(n.vertices),3)),void 0!==n.indices&&null!==n.indices&&l.setIndex(new BufferAttribute(new Uint32Array(n.indices),1)),void 0!==n.colors&&null!==n.colors&&l.addAttribute("color",new BufferAttribute(new Float32Array(n.colors),3)),void 0!==n.normals&&null!==n.normals?l.addAttribute("normal",new BufferAttribute(new Float32Array(n.normals),3)):l.computeVertexNormals(),void 0!==n.uvs&&null!==n.uvs&&l.addAttribute("uv",new BufferAttribute(new Float32Array(n.uvs),2)),void 0!==n.skinIndex&&null!==n.skinIndex&&l.addAttribute("skinIndex",new BufferAttribute(new Uint16Array(n.skinIndex),4)),void 0!==n.skinWeight&&null!==n.skinWeight&&l.addAttribute("skinWeight",new BufferAttribute(new Float32Array(n.skinWeight),4));let o=e.materials.materialNames,a=e.materials.multiMaterial,u=[];for(s in o)r=o[s],t=this.materialHandler.getMaterial(r),a&&u.push(t);if(a){t=u;let r,i=e.materials.materialGroups;for(s in i)r=i[s],l.addGroup(r.start,r.count,r.index)}let d,h,c=[],m=!0,f=null===e.geometryType?0:e.geometryType;if(this.callbacks.onMeshAlter&&(h=this.callbacks.onMeshAlter({detail:{meshName:i,bufferGeometry:l,material:t,geometryType:f}})),h)if(h.isDisregardMesh())m=!1;else if(h.providesAlteredMeshes()){for(let e in h.meshes)c.push(h.meshes[e]);m=!1}m&&(e.computeBoundingSphere&&l.computeBoundingSphere(),d=0===f?new Mesh(l,t):1===f?new LineSegments(l,t):new Points(l,t),d.name=i,c.push(d));let g=e.params.meshName;if(c.length>0){let t=[];for(let e in c)d=c[e],t[e]=d.name;g+=": Adding mesh(es) ("+t.length+": "+t+") from input mesh: "+i,g+=" ("+(100*e.progress.numericalValue).toFixed(2)+"%)"}else g+=": Not adding mesh: "+i,g+=" ("+(100*e.progress.numericalValue).toFixed(2)+"%)";return this.callbacks.onProgress&&this.callbacks.onProgress("progress",g,e.progress.numericalValue),c}};const LoadedMeshUserOverride=function(e,t){this.disregardMesh=!0===e,this.alteredMesh=!0===t,this.meshes=[]};LoadedMeshUserOverride.prototype={constructor:LoadedMeshUserOverride,addMesh:function(e){this.meshes.push(e),this.alteredMesh=!0},isDisregardMesh:function(){return this.disregardMesh},providesAlteredMeshes:function(){return this.alteredMesh}};export{MeshReceiver,LoadedMeshUserOverride};